var _Authentication_accessToken, _Authentication_config, _Authentication_leapAuthService, _Authentication_notification, _Authentication_refreshInfo, _Authentication_exchangeAuthCodeForAccessToken, _Authentication_verifyAndPerformRedirections, _Authentication_startRefreshAccessTokenProcess, _Authentication_destroyRefreshAccessTokenProcess, _Authentication_decodeAccessToken;
import { __awaiter, __classPrivateFieldGet, __classPrivateFieldSet } from "tslib";
import { isFunction } from 'lodash';
import { init } from './config';
import { LeapAuthService } from './auth.service';
import { HookName, } from './types';
import { Notification } from './notification';
import { createCodeChallenge, createRandomString, deleteQueryParameter, getQueryParameter } from './utils';
import { getRedirectUri } from './redirections';
const SECONDS_BEFORE_EXPIRE = 30;
const MAX_SETTIME_OUT = 2147483647;
const DEFAULT_AUTHORIZE_TIMEOUT_IN_SECONDS = 60;
const CLEANUP_IFRAME_TIMEOUT_IN_SECONDS = 2;
export class Authentication {
    constructor(options) {
        _Authentication_accessToken.set(this, void 0);
        _Authentication_config.set(this, void 0);
        _Authentication_leapAuthService.set(this, void 0);
        _Authentication_notification.set(this, void 0);
        _Authentication_refreshInfo.set(this, void 0);
        this.registerEventListenerForUserChannel = (params) => {
            const { topic, messageType, callback } = params;
            __classPrivateFieldGet(this, _Authentication_notification, "f").registerEventListenerForUserChannel({
                topic,
                messageType,
                callback,
            });
        };
        this.initNotification = () => __awaiter(this, void 0, void 0, function* () {
            const decodedToken = yield this.getDecodedRefreshedAccessToken();
            if (decodedToken) {
                yield __classPrivateFieldGet(this, _Authentication_notification, "f").init({
                    authHost: __classPrivateFieldGet(this, _Authentication_config, "f").authHost,
                    clientId: __classPrivateFieldGet(this, _Authentication_config, "f").clientId,
                    firmId: decodedToken.firmId,
                    userId: decodedToken.userId,
                    uniqueSession: !!__classPrivateFieldGet(this, _Authentication_config, "f").uniqueSession,
                    hooks: __classPrivateFieldGet(this, _Authentication_config, "f").hooks,
                });
            }
        });
        this.destroyNotification = () => {
            __classPrivateFieldGet(this, _Authentication_notification, "f").destroy();
        };
        this.login = (noPrompt) => __awaiter(this, void 0, void 0, function* () {
            const done = yield this.checkAuthCode();
            if (done && !!__classPrivateFieldGet(this, _Authentication_accessToken, "f")) {
                return __classPrivateFieldGet(this, _Authentication_accessToken, "f");
            }
            else {
                const code_verifier = createRandomString(64);
                const state = createRandomString(6);
                //* store verifier into browser session for later auth-code exchange
                window.sessionStorage.setItem(state, code_verifier);
                const { code_challenge, code_challenge_method } = yield createCodeChallenge(code_verifier);
                const scope = __classPrivateFieldGet(this, _Authentication_config, "f").scopes.join(',');
                const prompt = noPrompt ? 'none' : '';
                const url = `${__classPrivateFieldGet(this, _Authentication_config, "f").authHost}/oauth/authorize?response_type=code&scope=${scope}&client_id=${__classPrivateFieldGet(this, _Authentication_config, "f").clientId}&redirect_uri=${encodeURIComponent(window.location.href)}&code_challenge=${encodeURIComponent(code_challenge)}&code_challenge_method=${code_challenge_method}&state=${state}&prompt=${prompt}`;
                window.location.assign(url);
                return;
            }
        });
        this.logout = (force = false, redirectUrl) => {
            __classPrivateFieldSet(this, _Authentication_accessToken, undefined, "f");
            const redirectUri = encodeURIComponent(redirectUrl || window.location.href);
            window.location.href = `${__classPrivateFieldGet(this, _Authentication_config, "f").authHost}/oauth/logout?force=${force}&redirect_uri=${redirectUri}`;
            __classPrivateFieldGet(this, _Authentication_destroyRefreshAccessTokenProcess, "f").call(this);
        };
        this.getAccessToken = () => {
            if (__classPrivateFieldGet(this, _Authentication_accessToken, "f") === undefined || !__classPrivateFieldGet(this, _Authentication_accessToken, "f")) {
                return '';
            }
            else {
                return __classPrivateFieldGet(this, _Authentication_accessToken, "f");
            }
        };
        this.getRefreshedAccessToken = () => __awaiter(this, void 0, void 0, function* () {
            if (__classPrivateFieldGet(this, _Authentication_accessToken, "f") === undefined || !__classPrivateFieldGet(this, _Authentication_accessToken, "f")) {
                return '';
            }
            else {
                //* check whether there is a refresh token and whether access token is expired
                //* if it does, we refresh the token
                if (__classPrivateFieldGet(this, _Authentication_refreshInfo, "f") && __classPrivateFieldGet(this, _Authentication_refreshInfo, "f").accessTokenExpireIn) {
                    const decoded = __classPrivateFieldGet(this, _Authentication_decodeAccessToken, "f").call(this, __classPrivateFieldGet(this, _Authentication_accessToken, "f"));
                    if (!!decoded && ((decoded.exp - SECONDS_BEFORE_EXPIRE) * 1000 < Date.now())) {
                        const data = yield __classPrivateFieldGet(this, _Authentication_leapAuthService, "f").renewAccessToken({
                            refreshToken: __classPrivateFieldGet(this, _Authentication_refreshInfo, "f").refreshToken,
                            verifier: __classPrivateFieldGet(this, _Authentication_refreshInfo, "f").verifier,
                        });
                        if (data) {
                            if (data.refresh_token && data.expires_in) {
                                __classPrivateFieldSet(this, _Authentication_refreshInfo, Object.assign(Object.assign({}, __classPrivateFieldGet(this, _Authentication_refreshInfo, "f")), { refreshToken: data.refresh_token, accessTokenExpireIn: data.expires_in }), "f");
                            }
                            __classPrivateFieldSet(this, _Authentication_accessToken, data.access_token, "f");
                            yield this.triggerHooks(HookName.afterRefreshToken);
                            return __classPrivateFieldGet(this, _Authentication_accessToken, "f");
                        }
                    }
                }
                return __classPrivateFieldGet(this, _Authentication_accessToken, "f");
            }
        });
        //todo: need to replace the return type "any"
        this.getDecodedAccessToken = () => {
            if (!__classPrivateFieldGet(this, _Authentication_accessToken, "f")) {
                return undefined;
            }
            return __classPrivateFieldGet(this, _Authentication_decodeAccessToken, "f").call(this, __classPrivateFieldGet(this, _Authentication_accessToken, "f"));
        };
        //todo: need to replace the return type "any"
        this.getDecodedRefreshedAccessToken = () => __awaiter(this, void 0, void 0, function* () {
            const token = yield this.getRefreshedAccessToken();
            if (!token) {
                return undefined;
            }
            return __classPrivateFieldGet(this, _Authentication_decodeAccessToken, "f").call(this, token);
        });
        this.getHooks = () => {
            if (__classPrivateFieldGet(this, _Authentication_config, "f")) {
                return __classPrivateFieldGet(this, _Authentication_config, "f").hooks;
            }
            else {
                return undefined;
            }
        };
        this.setHook = (params) => {
            const { name, callback } = params;
            if (!Object.values(HookName).find((h) => h === name)) {
                throw Error('Unsupported hook: ' + name);
            }
            if (!isFunction(callback)) {
                throw Error('hook must be a function: ' + name);
            }
            __classPrivateFieldSet(this, _Authentication_config, Object.assign(Object.assign({}, __classPrivateFieldGet(this, _Authentication_config, "f")), { hooks: Object.assign(Object.assign({}, __classPrivateFieldGet(this, _Authentication_config, "f").hooks), { [name]: callback }) }), "f");
            if (name === HookName.uniqueSessionTrigger) {
                __classPrivateFieldGet(this, _Authentication_notification, "f").setUniqueSessionTriggerHook(callback);
            }
            return;
        };
        this.autoLogin = () => {
            return __classPrivateFieldGet(this, _Authentication_config, "f") ? __classPrivateFieldGet(this, _Authentication_config, "f").autoLogin || false : false;
        };
        this.autoLogout = () => {
            return __classPrivateFieldGet(this, _Authentication_config, "f") ? __classPrivateFieldGet(this, _Authentication_config, "f").autoLogin || false : false;
        };
        this.idleTimeoutInMinutes = () => {
            return __classPrivateFieldGet(this, _Authentication_config, "f") ? __classPrivateFieldGet(this, _Authentication_config, "f").idleTimeoutInMinutes || 30 : 30;
        };
        this.checkTokenInUrl = () => {
            const accessTokenQuery = getQueryParameter('access_token') || getQueryParameter('auth') || getQueryParameter('authToken') || getQueryParameter('token') || getQueryParameter('jwt');
            if (accessTokenQuery) {
                const { aud, firmId, userId } = __classPrivateFieldGet(this, _Authentication_decodeAccessToken, "f").call(this, accessTokenQuery);
                //* we make an exception to allow tokens from LD put in URLs to bypass authentication
                //* we need to have this exception for LD 2.3 (https://leapdev.atlassian.net/browse/AUTH-269)
                if (!!firmId && !!userId && aud === '8MBJWOFS4RRRSZQC') {
                    const queryParameterValue = accessTokenQuery;
                    let myselfWithoutToken = deleteQueryParameter(window.location.href, 'access_token', queryParameterValue);
                    myselfWithoutToken = deleteQueryParameter(myselfWithoutToken, 'token', queryParameterValue);
                    myselfWithoutToken = deleteQueryParameter(myselfWithoutToken, 'auth', queryParameterValue);
                    myselfWithoutToken = deleteQueryParameter(myselfWithoutToken, 'authToken', queryParameterValue);
                    myselfWithoutToken = deleteQueryParameter(myselfWithoutToken, 'jwt', queryParameterValue);
                    const myselfEncoded = encodeURIComponent(myselfWithoutToken);
                    window.location.href = __classPrivateFieldGet(this, _Authentication_config, "f").authHost + '/oauth/passthrough?token=' + queryParameterValue + '&redirect=' + myselfEncoded;
                    return true;
                }
                return false;
            }
            return false;
        };
        this.verifySession = () => __awaiter(this, void 0, void 0, function* () {
            const code_verifier = createRandomString(64);
            const state = createRandomString(6);
            //* store verifier into browser session for later auth-code exchange
            window.sessionStorage.setItem(state, code_verifier);
            const { code_challenge, code_challenge_method } = yield createCodeChallenge(code_verifier);
            const scope = __classPrivateFieldGet(this, _Authentication_config, "f").scopes.join(',');
            const redirectUri = `${window.location.protocol}//${window.location.host}${window.location.pathname}`;
            const url = `${__classPrivateFieldGet(this, _Authentication_config, "f").authHost}/oauth/authorize?response_type=code&response_mode=web_message&scope=${scope}&client_id=${__classPrivateFieldGet(this, _Authentication_config, "f").clientId}&redirect_uri=${encodeURIComponent(redirectUri)}&code_challenge=${encodeURIComponent(code_challenge)}&code_challenge_method=${code_challenge_method}&state=${state}&prompt=none`;
            const resp = yield this.runIframe(url, state);
            if (resp && resp.state) {
                const verifier = window.sessionStorage.getItem(resp.state);
                window.sessionStorage.removeItem(resp.state);
                if (resp.code && verifier) {
                    return __classPrivateFieldGet(this, _Authentication_exchangeAuthCodeForAccessToken, "f").call(this, {
                        code: resp.code,
                        verifier,
                        redirectUri
                    });
                }
                return false;
            }
            else {
                return false;
            }
        });
        this.checkAuthCode = () => __awaiter(this, void 0, void 0, function* () {
            const search = window.location.search;
            const queryParams = new URLSearchParams(search);
            const code = queryParams.get('code');
            const state = queryParams.get('state');
            //* check if "AuthCode" comes back from AuthServer
            if (!!code && !!state) {
                const verifier = window.sessionStorage.getItem(state);
                window.sessionStorage.removeItem(state);
                let newUrl = window.location.href;
                newUrl = deleteQueryParameter(newUrl, 'code', code);
                newUrl = deleteQueryParameter(newUrl, 'state', state);
                window.history.pushState(null, '', newUrl);
                //* use the Verifier and AuthCode to exchange for AccessToken
                return __classPrivateFieldGet(this, _Authentication_exchangeAuthCodeForAccessToken, "f").call(this, {
                    code,
                    verifier,
                    redirectUri: newUrl
                });
            }
            else {
                return false;
            }
        });
        this.getUserInfo = () => __awaiter(this, void 0, void 0, function* () {
            const token = yield this.getRefreshedAccessToken();
            return __classPrivateFieldGet(this, _Authentication_leapAuthService, "f").userInfo(token);
        });
        this.linkUser = (params) => __awaiter(this, void 0, void 0, function* () {
            const decodeToken = yield this.getDecodedRefreshedAccessToken();
            if (!decodeToken) {
                return;
            }
            const redirectUrl = params.redirectUrl || window.location.href;
            __classPrivateFieldGet(this, _Authentication_leapAuthService, "f").linkUser({
                redirectUrl,
                jti: decodeToken.jti,
                newWindow: params.newWindow,
                callback: params.callback,
            });
        });
        this.unlinkUser = (params) => __awaiter(this, void 0, void 0, function* () {
            const decodeToken = yield this.getDecodedRefreshedAccessToken();
            if (!decodeToken) {
                return;
            }
            const redirectUrl = params.redirectUrl || window.location.href;
            __classPrivateFieldGet(this, _Authentication_leapAuthService, "f").unlinkUser({
                redirectUrl,
                jti: decodeToken.jti,
                newWindow: params.newWindow,
                callback: params.callback,
            });
        });
        this.getCloudProviderToken = (jti) => __awaiter(this, void 0, void 0, function* () {
            const token = yield this.getRefreshedAccessToken();
            if (!token) {
                throw Error('Not authenticated yet');
            }
            return __classPrivateFieldGet(this, _Authentication_leapAuthService, "f").getCloudProviderToken(token, jti);
        });
        this.cloudProviderUserInfo = () => __awaiter(this, void 0, void 0, function* () {
            const token = yield this.getRefreshedAccessToken();
            if (!token) {
                throw Error('Not authenticated yet');
            }
            return __classPrivateFieldGet(this, _Authentication_leapAuthService, "f").cloudProviderUserInfo(token);
        });
        this.cloudProviderReauthenticate = (params) => __awaiter(this, void 0, void 0, function* () {
            const token = yield this.getRefreshedAccessToken();
            if (!token) {
                throw Error('Not authenticated yet');
            }
            let { nonce, redirectUrl } = params;
            const { newWindow, callback } = params;
            redirectUrl = redirectUrl || window.location.href;
            if (!nonce) {
                const reauthticateLink = yield __classPrivateFieldGet(this, _Authentication_leapAuthService, "f").cloudProviderReauthenticateLink(token);
                nonce = reauthticateLink.nonce;
            }
            return __classPrivateFieldGet(this, _Authentication_leapAuthService, "f").cloudProviderReauthenticate({
                redirectUrl,
                nonce,
                newWindow,
                callback,
            });
        });
        this.cloudProviderUpdate = (cloudProviderId) => __awaiter(this, void 0, void 0, function* () {
            const token = yield this.getRefreshedAccessToken();
            if (!token) {
                throw Error('Not authenticated yet');
            }
            const decodedToken = __classPrivateFieldGet(this, _Authentication_decodeAccessToken, "f").call(this, token);
            const { firmId } = decodedToken;
            return __classPrivateFieldGet(this, _Authentication_leapAuthService, "f").cloudProviderUpdate({ firmId, cloudProviderId, token: token });
        });
        this.statusAdminConsent = () => __awaiter(this, void 0, void 0, function* () {
            const token = yield this.getRefreshedAccessToken();
            if (!token) {
                throw Error('Not authenticated yet');
            }
            return __classPrivateFieldGet(this, _Authentication_leapAuthService, "f").statusAdminConsent(token);
        });
        this.getAdminConsent = (params) => {
            const redirectUrl = params.redirectUrl || window.location.href;
            __classPrivateFieldGet(this, _Authentication_leapAuthService, "f").getAdminConsent(Object.assign(Object.assign({}, params), { redirectUrl }));
        };
        this.revokeAdminConsent = () => __awaiter(this, void 0, void 0, function* () {
            const token = yield this.getRefreshedAccessToken();
            if (!token) {
                throw Error('Not authenticated yet');
            }
            return __classPrivateFieldGet(this, _Authentication_leapAuthService, "f").revokeAdminConsent(token);
        });
        this.getLinkMap = (allUsers = false) => __awaiter(this, void 0, void 0, function* () {
            const token = yield this.getRefreshedAccessToken();
            if (!token) {
                throw Error('Not authenticated yet');
            }
            return __classPrivateFieldGet(this, _Authentication_leapAuthService, "f").getLinkMap(token, allUsers);
        });
        this.setLinkMap = (linkMap) => __awaiter(this, void 0, void 0, function* () {
            const token = yield this.getRefreshedAccessToken();
            if (!token) {
                throw Error('Not authenticated yet');
            }
            const verifyFormat = () => {
                if (Array.isArray(linkMap)) {
                    for (const link of linkMap) {
                        if (!(link.internalUser && link.externalUser && link.externalUser.id))
                            return false;
                    }
                    return true;
                }
                return false;
            };
            if (!verifyFormat())
                throw Error('linkmap in wrong format');
            return __classPrivateFieldGet(this, _Authentication_leapAuthService, "f").setLinkMap(token, linkMap);
        });
        this.authoriseSupport = (params) => __awaiter(this, void 0, void 0, function* () {
            const token = yield this.getRefreshedAccessToken();
            if (!token) {
                throw Error('Not authenticated yet');
            }
            return __classPrivateFieldGet(this, _Authentication_leapAuthService, "f").authoriseSupport(token, params);
        });
        this.changePassword = (params) => {
            const redirectUrl = params.redirectUrl || window.location.href;
            __classPrivateFieldGet(this, _Authentication_leapAuthService, "f").changePassword(Object.assign(Object.assign({}, params), { redirectUrl }));
        };
        this.passthrough = (params) => __awaiter(this, void 0, void 0, function* () {
            const decodedToken = yield this.getDecodedRefreshedAccessToken();
            if (decodedToken && decodedToken.jti) {
                const { url, newWindow, authHost } = params;
                const encodedRedirectUrl = encodeURIComponent(url);
                const passthroughUrl = `${authHost || __classPrivateFieldGet(this, _Authentication_config, "f").authHost}/oauth/passthrough?jti=${decodedToken.jti}&redirect=${encodedRedirectUrl}&output=embed`;
                if (newWindow) {
                    window.open(passthroughUrl, '_blank');
                }
                else {
                    window.location.assign(passthroughUrl);
                }
            }
            return;
        });
        this.triggerHooks = (hookName) => __awaiter(this, void 0, void 0, function* () {
            const hooks = this.getHooks();
            const token = yield this.getRefreshedAccessToken();
            const hookFn = hooks && !!hooks[hookName] && isFunction(hooks[hookName]) ? hooks[hookName](token) : false;
            return Promise.resolve(hookFn);
        });
        this.afterAuthenticated = () => {
            return this.triggerHooks(HookName.afterLogin).then(() => __awaiter(this, void 0, void 0, function* () {
                yield this.initNotification();
                return __classPrivateFieldGet(this, _Authentication_accessToken, "f");
            }));
        };
        this.runIframe = (authorizeUrl, state, timeoutInSeconds = DEFAULT_AUTHORIZE_TIMEOUT_IN_SECONDS) => {
            return new Promise((res, rej) => {
                const iframe = window.document.createElement('iframe');
                iframe.setAttribute('width', '0');
                iframe.setAttribute('height', '0');
                iframe.setAttribute('id', 'agent-iframe');
                iframe.style.display = 'none';
                const removeIframe = () => {
                    if (window.document.body.contains(iframe)) {
                        window.document.body.removeChild(iframe);
                        window.removeEventListener('message', iframeEventHandler, false);
                    }
                };
                const timeoutSetTimeoutId = setTimeout(() => {
                    rej('agent-iframe timeout');
                    removeIframe();
                    window.sessionStorage.removeItem(state);
                }, timeoutInSeconds * 1000);
                const iframeEventHandler = (e) => {
                    const { data, origin, source } = e;
                    if (origin !== __classPrivateFieldGet(this, _Authentication_config, "f").authHost)
                        return;
                    if (!data || data.type !== 'authorization_response')
                        return;
                    if (source) {
                        source.close();
                    }
                    res(data.response);
                    clearTimeout(timeoutSetTimeoutId);
                    window.removeEventListener('message', iframeEventHandler, false);
                    setTimeout(removeIframe, CLEANUP_IFRAME_TIMEOUT_IN_SECONDS * 1000);
                };
                window.addEventListener('message', iframeEventHandler, false);
                window.document.body.appendChild(iframe);
                iframe.setAttribute('src', authorizeUrl);
            });
        };
        _Authentication_exchangeAuthCodeForAccessToken.set(this, (params) => __awaiter(this, void 0, void 0, function* () {
            const { verifier, code, redirectUri } = params;
            if (verifier) {
                const data = yield __classPrivateFieldGet(this, _Authentication_leapAuthService, "f").exchangeAuthCodeForAccessToken({
                    code,
                    verifier,
                    redirectUri
                });
                const redirectTriggered = yield __classPrivateFieldGet(this, _Authentication_verifyAndPerformRedirections, "f").call(this, data.access_token);
                if (redirectTriggered) {
                    return true;
                }
                if (data.refresh_token &&
                    data.expires_in) {
                    __classPrivateFieldSet(this, _Authentication_refreshInfo, {
                        refreshToken: data.refresh_token,
                        accessTokenExpireIn: data.expires_in,
                        verifier: verifier,
                        timer: undefined,
                    }, "f");
                    if (__classPrivateFieldGet(this, _Authentication_config, "f").autoRefreshToken) {
                        __classPrivateFieldGet(this, _Authentication_startRefreshAccessTokenProcess, "f").call(this);
                    }
                }
                //* store access token in memory
                __classPrivateFieldSet(this, _Authentication_accessToken, data.access_token, "f");
                return true;
            }
            else {
                return false;
            }
        }));
        _Authentication_verifyAndPerformRedirections.set(this, (accessToken) => __awaiter(this, void 0, void 0, function* () {
            const redirectionConfig = yield __classPrivateFieldGet(this, _Authentication_leapAuthService, "f").getRedirections();
            const origin = window.location.origin;
            const decodedToken = __classPrivateFieldGet(this, _Authentication_decodeAccessToken, "f").call(this, accessToken);
            const redirectUri = getRedirectUri(origin, decodedToken, redirectionConfig);
            if (redirectUri) {
                this.logout(false, redirectUri);
                return true;
            }
            return false;
        }));
        _Authentication_startRefreshAccessTokenProcess.set(this, () => {
            if (!__classPrivateFieldGet(this, _Authentication_refreshInfo, "f")) {
                return;
            }
            if (__classPrivateFieldGet(this, _Authentication_refreshInfo, "f").timer) {
                clearTimeout(__classPrivateFieldGet(this, _Authentication_refreshInfo, "f").timer);
                __classPrivateFieldSet(this, _Authentication_refreshInfo, Object.assign(Object.assign({}, __classPrivateFieldGet(this, _Authentication_refreshInfo, "f")), { timer: undefined }), "f");
            }
            const waitBeforeExecuting = (__classPrivateFieldGet(this, _Authentication_refreshInfo, "f").accessTokenExpireIn - SECONDS_BEFORE_EXPIRE) * 1000;
            //* the max for setTimeout delay is 2147483647 ms or 24.855 days
            //* if token expire time is greater than the max, we ignore the refresh process as it is not realistic to let browser open more than 24 days and wait for token got refreshed.
            if (waitBeforeExecuting > MAX_SETTIME_OUT) {
                return;
            }
            const timer = setTimeout(() => __awaiter(this, void 0, void 0, function* () {
                if (!__classPrivateFieldGet(this, _Authentication_refreshInfo, "f")) {
                    return;
                }
                const data = yield __classPrivateFieldGet(this, _Authentication_leapAuthService, "f").renewAccessToken({
                    refreshToken: __classPrivateFieldGet(this, _Authentication_refreshInfo, "f").refreshToken,
                    verifier: __classPrivateFieldGet(this, _Authentication_refreshInfo, "f").verifier,
                });
                if (data) {
                    if (data.refresh_token && data.expires_in) {
                        __classPrivateFieldSet(this, _Authentication_refreshInfo, Object.assign(Object.assign({}, __classPrivateFieldGet(this, _Authentication_refreshInfo, "f")), { refreshToken: data.refresh_token, accessTokenExpireIn: data.expires_in }), "f");
                        __classPrivateFieldGet(this, _Authentication_startRefreshAccessTokenProcess, "f").call(this);
                    }
                    __classPrivateFieldSet(this, _Authentication_accessToken, data.access_token, "f");
                    yield this.triggerHooks(HookName.afterRefreshToken);
                }
            }), waitBeforeExecuting);
            __classPrivateFieldSet(this, _Authentication_refreshInfo, Object.assign(Object.assign({}, __classPrivateFieldGet(this, _Authentication_refreshInfo, "f")), { timer }), "f");
        });
        _Authentication_destroyRefreshAccessTokenProcess.set(this, () => {
            if (!__classPrivateFieldGet(this, _Authentication_refreshInfo, "f")) {
                return;
            }
            if (__classPrivateFieldGet(this, _Authentication_refreshInfo, "f").timer) {
                clearTimeout(__classPrivateFieldGet(this, _Authentication_refreshInfo, "f").timer);
            }
            __classPrivateFieldSet(this, _Authentication_refreshInfo, undefined, "f");
        });
        _Authentication_decodeAccessToken.set(this, (accessToken) => {
            if (!accessToken) {
                return undefined;
            }
            const payload = accessToken.split('.')[1];
            if (payload) {
                try {
                    const result = window.atob(payload);
                    return JSON.parse(result);
                }
                catch (e) {
                    throw Error('Fail to decode access token.');
                }
            }
            return undefined;
        });
        __classPrivateFieldSet(this, _Authentication_accessToken, undefined, "f");
        __classPrivateFieldSet(this, _Authentication_config, init(options), "f");
        __classPrivateFieldSet(this, _Authentication_leapAuthService, new LeapAuthService(__classPrivateFieldGet(this, _Authentication_config, "f").authHost, __classPrivateFieldGet(this, _Authentication_config, "f").clientId), "f");
        __classPrivateFieldSet(this, _Authentication_notification, new Notification(), "f");
    }
}
_Authentication_accessToken = new WeakMap(), _Authentication_config = new WeakMap(), _Authentication_leapAuthService = new WeakMap(), _Authentication_notification = new WeakMap(), _Authentication_refreshInfo = new WeakMap(), _Authentication_exchangeAuthCodeForAccessToken = new WeakMap(), _Authentication_verifyAndPerformRedirections = new WeakMap(), _Authentication_startRefreshAccessTokenProcess = new WeakMap(), _Authentication_destroyRefreshAccessTokenProcess = new WeakMap(), _Authentication_decodeAccessToken = new WeakMap();
//# sourceMappingURL=authentication.js.map