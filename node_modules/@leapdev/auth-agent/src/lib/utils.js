import { __awaiter } from "tslib";
export const deleteQueryParameter = (windowLocation, name, value) => {
    const nameValue = name + '=' + value;
    let toReplace = nameValue;
    if (windowLocation.indexOf('?' + nameValue) >= 0) {
        if (windowLocation.indexOf('?' + nameValue + '&') >= 0) { // first param
            toReplace += '&';
        }
        else { // first and unique param
            toReplace = '?' + toReplace;
        }
    }
    else if (windowLocation.indexOf('&' + nameValue) >= 0) { // not first param (maybe last)
        toReplace = '&' + toReplace;
    }
    return windowLocation.replace(toReplace, '');
};
export const getQueryParameter = (name) => {
    const paramsForSearch = parseParams(window.location.search.substring(1));
    if (paramsForSearch[name]) {
        return paramsForSearch[name];
    }
    return undefined;
};
export const createCodeChallenge = (verifier) => __awaiter(void 0, void 0, void 0, function* () {
    if (getCryptoSubtle()) {
        const code_challengeBuffer = yield sha256(verifier);
        const code_challenge = bufferToBase64UrlEncoded(code_challengeBuffer);
        return { code_challenge, code_challenge_method: 'S256' };
    }
    else {
        return { code_challenge: verifier, code_challenge_method: undefined };
    }
});
export const getCrypto = () => {
    //ie 11.x uses msCrypto
    return (window.crypto || window.msCrypto);
};
export const createRandomString = (size) => {
    const charset = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
    let random = '';
    const randomValues = Array.from(getCrypto().getRandomValues(new Uint8Array(size)));
    randomValues.forEach(v => (random += charset[v % charset.length]));
    return random;
};
const sha256 = (s) => __awaiter(void 0, void 0, void 0, function* () {
    const digestOp = getCryptoSubtle().digest({ name: 'SHA-256' }, new TextEncoder().encode(s));
    // msCrypto (IE11) uses the old spec, which is not Promise based
    // https://msdn.microsoft.com/en-us/expression/dn904640(v=vs.71)
    // Instead of returning a promise, it returns a CryptoOperation
    // with a result property in it.
    // As a result, the various events need to be handled in the event that we're
    // working in IE11 (hence the msCrypto check). These events just call resolve
    // or reject depending on their intention.
    if (window.msCrypto) {
        return new Promise((res, rej) => {
            digestOp.oncomplete = (e) => {
                res(e.target.result);
            };
            digestOp.onerror = (e) => {
                rej(e.error);
            };
            digestOp.onabort = () => {
                rej('The digest operation was aborted');
            };
        });
    }
    return yield digestOp;
});
const getCryptoSubtle = () => {
    const crypto = getCrypto();
    //safari 10.x uses webkitSubtle
    return crypto.subtle || crypto.webkitSubtle;
};
const bufferToBase64UrlEncoded = (input) => {
    const ie11SafeInput = new Uint8Array(input);
    return urlEncodeB64(window.btoa(String.fromCharCode(...Array.from(ie11SafeInput))));
};
const urlEncodeB64 = (input) => {
    const b64Chars = { '+': '-', '/': '_', '=': '' };
    return input.replace(/[+/=]/g, (m) => b64Chars[m]);
};
const parseParams = (url) => {
    const result = {};
    const params = url.split('&');
    for (let i = 0; i < params.length; i++) {
        const param = params[i].split('=', 2);
        if (param.length !== 2)
            continue;
        result[param[0]] = decodeURIComponent(param[1].replace(/\+/g, " "));
    }
    return result;
};
//# sourceMappingURL=utils.js.map