var _Notification_pubnubKeys, _Notification_pubnub, _Notification_eventListeners, _Notification_uniqueSessionTriggerHook, _Notification_initFirmChannel, _Notification_initUserChannel, _Notification_initUniqueSessionChannel;
import { __awaiter, __classPrivateFieldGet, __classPrivateFieldSet } from "tslib";
import { v4 as uuidv4 } from 'uuid';
import Pubnub from "pubnub";
import { AuthAgent } from './auth-agent';
import { isFunction } from 'lodash';
const EMPTY_GUID = '00000000-0000-0000-0000-000000000000';
const USER_ACTION = {
    USERNAME_CHANGED: '1',
    PASSWORD_CHANGED: '2',
    USER_DISABLED: '3', //     3 - User has been disabled
};
export class Notification {
    constructor() {
        _Notification_pubnubKeys.set(this, void 0);
        _Notification_pubnub.set(this, void 0);
        _Notification_eventListeners.set(this, []);
        _Notification_uniqueSessionTriggerHook.set(this, undefined);
        this.init = (params) => __awaiter(this, void 0, void 0, function* () {
            const { authHost, clientId, firmId, userId, uniqueSession, hooks } = params;
            if (!!hooks && hooks.uniqueSessionTrigger) {
                __classPrivateFieldSet(this, _Notification_uniqueSessionTriggerHook, hooks.uniqueSessionTrigger, "f");
            }
            ;
            __classPrivateFieldGet(this, _Notification_initFirmChannel, "f").call(this, firmId, userId);
            __classPrivateFieldGet(this, _Notification_initUserChannel, "f").call(this, userId);
            if (uniqueSession) {
                yield __classPrivateFieldGet(this, _Notification_initUniqueSessionChannel, "f").call(this, { authHost, clientId });
            }
        });
        this.destroy = () => {
            if (__classPrivateFieldGet(this, _Notification_pubnub, "f")) {
                __classPrivateFieldGet(this, _Notification_pubnub, "f").unsubscribeAll();
                __classPrivateFieldSet(this, _Notification_eventListeners, [], "f");
            }
        };
        this.registerEventListenerForUserChannel = (params) => {
            const { topic, messageType, callback } = params;
            if (!isFunction(callback)) {
                throw Error(`Registering Event Listener ${topic} ${messageType}: callback needs to be a function`);
            }
            __classPrivateFieldGet(this, _Notification_eventListeners, "f").push({ topic, messageType, callback });
        };
        this.setUniqueSessionTriggerHook = (hook) => {
            __classPrivateFieldSet(this, _Notification_uniqueSessionTriggerHook, hook, "f");
        };
        _Notification_initFirmChannel.set(this, (firmId, userId) => {
            __classPrivateFieldGet(this, _Notification_pubnub, "f").addListener({
                presence: (presenceEvent) => {
                    //* handle presence
                    const { action, uuid } = presenceEvent;
                    //* the message was sent from the current pubnub instance
                    if (uuid === __classPrivateFieldGet(this, _Notification_pubnubKeys, "f").uuid) {
                        return;
                    }
                    //* handle action 'leave' and 'timeout'
                    if (action === 'leave' || action === 'timeout') {
                        const valuesUUID = uuid.split('~');
                        const userIdFromPresence = valuesUUID[0] || '';
                        const instanceGuidFromPresence = valuesUUID[1] || '';
                        const userActionFromPresence = valuesUUID[2] || '';
                        const isUserActionRequiredLogout = userActionFromPresence === USER_ACTION.USERNAME_CHANGED ||
                            userActionFromPresence === USER_ACTION.PASSWORD_CHANGED ||
                            userActionFromPresence === USER_ACTION.USER_DISABLED;
                        if (userIdFromPresence === userId &&
                            instanceGuidFromPresence === EMPTY_GUID &&
                            isUserActionRequiredLogout) {
                            //* User Information has been changed, force user to logout
                            AuthAgent.logout(true); // call logout with force=true (because the logout is forced)
                        }
                    }
                },
            });
            __classPrivateFieldGet(this, _Notification_pubnub, "f").subscribe({
                channels: [firmId],
                withPresence: true,
            });
        });
        _Notification_initUserChannel.set(this, (userId) => {
            __classPrivateFieldGet(this, _Notification_pubnub, "f").addListener({
                message: (data) => {
                    const { content } = data.message;
                    if (content && content.topic && content.messageType && content.data) {
                        for (const eventListener of __classPrivateFieldGet(this, _Notification_eventListeners, "f")) {
                            if (eventListener.topic === content.topic &&
                                eventListener.messageType === content.messageType &&
                                eventListener.callback &&
                                isFunction(eventListener.callback)) {
                                return eventListener.callback(content.data);
                            }
                        }
                    }
                },
            });
            __classPrivateFieldGet(this, _Notification_pubnub, "f").subscribe({
                channels: [`user_${userId}`],
                withPresence: false,
            });
        });
        _Notification_initUniqueSessionChannel.set(this, (params) => __awaiter(this, void 0, void 0, function* () {
            const decodedToken = yield AuthAgent.getDecodedAccessToken();
            const { authHost: myAuthHost, clientId: myClientId } = params;
            const { userId: myUserId, sessionId: mySessionId, impersonatorId: myImpersonatorId, } = decodedToken;
            if (!decodedToken) {
                return;
            }
            const channel = `auth-session-${myUserId}`;
            __classPrivateFieldGet(this, _Notification_pubnub, "f").addListener({
                message: (data) => __awaiter(this, void 0, void 0, function* () {
                    const decodedToken = yield AuthAgent.getDecodedAccessToken();
                    if (!decodedToken) {
                        AuthAgent.logout(true); // call logout with force=true (because the logout is forced)
                    }
                    const { sessionId: mySessionId, impersonatorId: myImpersonatorId, userId: myUserId, } = decodedToken;
                    const myAgentId = localStorage.getItem('leap-auth-agent-id');
                    if (myAgentId && data && data.message) {
                        const sessionId = data.message.sessionId, authHost = data.message.authHost, clientId = data.message.clientId, logout = data.message.logout, agentId = data.message.agentId, impersonatorId = myImpersonatorId
                            ? myImpersonatorId
                            : data.message.impersonatorId;
                        if (authHost === myAuthHost) {
                            if ((clientId === myClientId && agentId !== myAgentId) || // same application, different browser => logout (unique session feature)
                                (clientId !== myClientId && agentId === myAgentId && logout) // different application, same browser, logout asked by user => logout (unique logout feature)
                            ) {
                                if (impersonatorId !== undefined && impersonatorId !== '') {
                                    // I'm impersonating someone who is being logged in or out so I don't want to be logged out
                                    console.log('user ' + impersonatorId + ' impersonating user ' + myUserId);
                                }
                                else {
                                    if (!!__classPrivateFieldGet(this, _Notification_uniqueSessionTriggerHook, "f") && isFunction(__classPrivateFieldGet(this, _Notification_uniqueSessionTriggerHook, "f"))) {
                                        __classPrivateFieldGet(this, _Notification_uniqueSessionTriggerHook, "f").call(this);
                                    }
                                    else {
                                        AuthAgent.logout(true); // call logout with force=true (because the logout is forced)
                                    }
                                }
                            }
                        }
                    }
                }),
            });
            __classPrivateFieldGet(this, _Notification_pubnub, "f").subscribe({
                channels: [channel],
                withPresence: true,
            });
            let agentId = localStorage.getItem('leap-auth-agent-id');
            if (!agentId) {
                agentId = uuidv4();
                localStorage.setItem('leap-auth-agent-id', agentId);
            }
            __classPrivateFieldGet(this, _Notification_pubnub, "f").publish({
                message: {
                    authHost: myAuthHost,
                    clientId: myClientId,
                    sessionId: mySessionId,
                    agentId: agentId,
                    impersonatorId: myImpersonatorId,
                },
                channel: channel,
            }, (status) => {
                if (status.error) {
                    console.log('pubnub error');
                }
            });
        }));
        __classPrivateFieldSet(this, _Notification_pubnubKeys, {
            publishKey: 'pub-13f5288e-cd88-4ef9-9e68-0c11cd03ddb8',
            subscribeKey: 'sub-a456f002-0095-11e2-9638-9581afc33ebf',
            uuid: uuidv4(),
        }, "f");
        __classPrivateFieldSet(this, _Notification_pubnub, new Pubnub(__classPrivateFieldGet(this, _Notification_pubnubKeys, "f")), "f");
    }
}
_Notification_pubnubKeys = new WeakMap(), _Notification_pubnub = new WeakMap(), _Notification_eventListeners = new WeakMap(), _Notification_uniqueSessionTriggerHook = new WeakMap(), _Notification_initFirmChannel = new WeakMap(), _Notification_initUserChannel = new WeakMap(), _Notification_initUniqueSessionChannel = new WeakMap();
//# sourceMappingURL=notification.js.map