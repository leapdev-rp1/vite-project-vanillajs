import { __awaiter } from "tslib";
import { Authentication } from './authentication';
import { IdleTimer } from './idle-timer';
import { HookName } from './types';
let auth;
const init = (options) => __awaiter(void 0, void 0, void 0, function* () {
    auth = new Authentication(options);
    if (!auth) {
        return false;
    }
    if (auth.autoLogout()) {
        const timeoutInMinutes = auth.idleTimeoutInMinutes();
        const idleTimer = new IdleTimer({ timeoutInMinutes, onTimeout: logout });
        idleTimer.tracker();
    }
    //* we need to have this exception for LD 2.3 (https://leapdev.atlassian.net/browse/AUTH-269)
    const passthrough = auth.checkTokenInUrl();
    if (passthrough) {
        return false;
    }
    //* check if authCode in URL
    const done = yield auth.checkAuthCode();
    if (done) {
        return auth.afterAuthenticated();
    }
    //* check if there is an existing auth session
    const hasAuthSession = yield verifySession();
    if (hasAuthSession) {
        return auth.afterAuthenticated();
    }
    const autoLogin = auth.autoLogin();
    if (autoLogin) {
        yield login();
    }
    return true;
});
const verifySession = () => __awaiter(void 0, void 0, void 0, function* () {
    if (!auth) {
        throw Error('Not init yet');
    }
    return yield auth.verifySession();
});
const getAccessToken = () => {
    return !auth ? '' : auth.getAccessToken();
};
const getRefreshedAccessToken = () => __awaiter(void 0, void 0, void 0, function* () {
    return !auth ? '' : yield auth.getRefreshedAccessToken();
});
const login = () => __awaiter(void 0, void 0, void 0, function* () {
    if (!auth) {
        throw Error('Not init yet');
    }
    return auth.login().then((token) => {
        return token && auth ? auth.afterAuthenticated() : undefined;
    });
});
const logout = (force = false, redirectUrl) => __awaiter(void 0, void 0, void 0, function* () {
    if (!auth) {
        throw Error('Not init yet');
    }
    return auth.triggerHooks(HookName.beforeLogout)
        .then(() => {
        if (auth) {
            auth.destroyNotification();
            auth.logout(force, redirectUrl);
        }
        return;
    })
        .catch(function (err) {
        console.error('Error while logging out : ', err);
        throw Error(err);
    });
});
const registerHook = (hookName, callback) => {
    if (!auth) {
        throw Error('Not init yet');
    }
    if (auth) {
        auth.setHook({ name: hookName, callback });
    }
    return;
};
const getDecodedAccessToken = () => {
    if (!auth) {
        throw Error('Not init yet');
    }
    return auth.getDecodedAccessToken();
};
const getDecodedRefreshedAccessToken = () => __awaiter(void 0, void 0, void 0, function* () {
    if (!auth) {
        throw Error('Not init yet');
    }
    return yield auth.getDecodedRefreshedAccessToken();
});
const userInfo = () => {
    if (!auth) {
        throw Error('Not init yet');
    }
    return auth.getUserInfo();
};
const linkUser = (redirectUrl, newWindow, callback) => __awaiter(void 0, void 0, void 0, function* () {
    if (!auth) {
        throw Error('Not init yet');
    }
    yield auth.linkUser({ redirectUrl, newWindow, callback });
});
const unlinkUser = (redirectUrl, newWindow, callback) => __awaiter(void 0, void 0, void 0, function* () {
    if (!auth) {
        throw Error('Not init yet');
    }
    yield auth.unlinkUser({ redirectUrl, newWindow, callback });
});
const getCloudProviderToken = (jti) => {
    if (!auth) {
        throw Error('Not init yet');
    }
    return auth.getCloudProviderToken(jti);
};
const cloudProviderUserInfo = () => {
    if (!auth) {
        throw Error('Not init yet');
    }
    return auth.cloudProviderUserInfo();
};
const cloudProviderReauthenticate = (nonce, redirectUrl, newWindow, callback) => {
    if (!auth) {
        throw Error('Not init yet');
    }
    return auth.cloudProviderReauthenticate({
        redirectUrl,
        nonce,
        newWindow,
        callback,
    });
};
const cloudProviderUpdate = (cloudProviderId) => {
    if (!auth) {
        throw Error('Not init yet');
    }
    if (!cloudProviderId) {
        throw Error('cloudProviderId is required');
    }
    return auth.cloudProviderUpdate(cloudProviderId);
};
const statusAdminConsent = () => {
    if (!auth) {
        throw Error('Not init yet');
    }
    return auth.statusAdminConsent();
};
const getAdminConsent = (domain, redirectUrl, newWindow, callback) => {
    if (!auth) {
        throw Error('Not init yet');
    }
    auth.getAdminConsent({ domain, redirectUrl, newWindow, callback });
};
const revokeAdminConsent = () => {
    if (!auth) {
        throw Error('Not init yet');
    }
    return auth.revokeAdminConsent();
};
const getLinkMap = (allUsers) => {
    if (!auth) {
        throw Error('Not init yet');
    }
    return auth.getLinkMap(allUsers);
};
const setLinkMap = (linkMap) => {
    if (!auth) {
        throw Error('Not init yet');
    }
    return auth.setLinkMap(linkMap);
};
const authoriseSupport = (code, duration) => {
    if (!auth) {
        throw Error('Not init yet');
    }
    return auth.authoriseSupport({ code, duration });
};
const changePassword = (redirectUrl, newWindow, callback) => {
    if (!auth) {
        throw Error('Not init yet');
    }
    auth.changePassword({ redirectUrl, newWindow, callback });
};
const registerEventListener = (topic, messageType, callback) => {
    if (!auth) {
        throw Error('Not init yet');
    }
    auth.registerEventListenerForUserChannel({ topic, messageType, callback });
};
const passthrough = (url, newWindow = false, authHost) => __awaiter(void 0, void 0, void 0, function* () {
    if (!auth) {
        throw Error('Not init yet');
    }
    yield auth.passthrough({ url, newWindow, authHost });
});
export const AuthAgent = {
    init,
    registerHook,
    login,
    logout,
    getAccessToken,
    getRefreshedAccessToken,
    getDecodedAccessToken,
    getDecodedRefreshedAccessToken,
    userInfo,
    linkUser,
    unlinkUser,
    getCloudProviderToken,
    cloudProviderUserInfo,
    cloudProviderReauthenticate,
    cloudProviderUpdate,
    statusAdminConsent,
    getAdminConsent,
    revokeAdminConsent,
    getLinkMap,
    setLinkMap,
    authoriseSupport,
    changePassword,
    registerEventListener,
    passthrough,
};
//# sourceMappingURL=auth-agent.js.map